{"version":3,"sources":["../../../src/utils/dynamic-position.js"],"names":["ANCHOR_POSITION","top","x","y","bottom","left","right","ANCHOR_TYPES","Object","keys","getDynamicPosition","width","height","selfWidth","selfHeight","anchor","padding","anchorX","anchorY","cutoffY","Math","max","bestAnchorY","minCutoff","xStep","floor","cutoffX","bestAnchorX","find","positionType","anchorPosition"],"mappings":"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","sourcesContent":["// @flow\n\nexport const ANCHOR_POSITION = {\n  top: {x: 0.5, y: 0},\n  'top-left': {x: 0, y: 0},\n  'top-right': {x: 1, y: 0},\n  bottom: {x: 0.5, y: 1},\n  'bottom-left': {x: 0, y: 1},\n  'bottom-right': {x: 1, y: 1},\n  left: {x: 0, y: 0.5},\n  right: {x: 1, y: 0.5}\n};\n\nexport type PositionType = $Keys<typeof ANCHOR_POSITION>;\n\nconst ANCHOR_TYPES = Object.keys(ANCHOR_POSITION);\n\n/**\n * Calculate the dynamic position for a popup to fit in a container.\n * @param {Number} x - x position of the anchor on screen\n * @param {Number} y - y position of the anchor on screen\n * @param {Number} width - width of the container\n * @param {Number} height - height of the container\n * @param {Number} padding - extra space from the edge in pixels\n * @param {Number} selfWidth - width of the popup\n * @param {Number} selfHeight - height of the popup\n * @param {String} anchor - type of the anchor, one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n * @returns {String} position - one of 'top', 'bottom',\n    'left', 'right', 'top-left', 'top-right', 'bottom-left' , and  'bottom-right'\n */\n// eslint-disable-next-line complexity,max-statements\nexport function getDynamicPosition({\n  x,\n  y,\n  width,\n  height,\n  selfWidth,\n  selfHeight,\n  anchor,\n  padding = 0\n}: {\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  selfWidth: number,\n  selfHeight: number,\n  anchor: PositionType,\n  padding: number\n}): PositionType {\n  let {x: anchorX, y: anchorY} = ANCHOR_POSITION[anchor];\n\n  // anchorY: top - 0, center - 0.5, bottom - 1\n  let top = y - anchorY * selfHeight;\n  let bottom = top + selfHeight;\n  let cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n\n  if (cutoffY > 0) {\n    // Needs vertical adjustment\n    let bestAnchorY = anchorY;\n    let minCutoff = cutoffY;\n    // Test anchorY at 0.5 step between [0, 1]\n    for (anchorY = 0; anchorY <= 1; anchorY += 0.5) {\n      top = y - anchorY * selfHeight;\n      bottom = top + selfHeight;\n      cutoffY = Math.max(0, padding - top) + Math.max(0, bottom - height + padding);\n      if (cutoffY < minCutoff) {\n        minCutoff = cutoffY;\n        bestAnchorY = anchorY;\n      }\n    }\n    anchorY = bestAnchorY;\n  }\n\n  // If needed, adjust anchorX at 0.5 step between [0, 1]\n  let xStep = 0.5;\n  if (anchorY === 0.5) {\n    // If y is centered, then x cannot also be centered\n    anchorX = Math.floor(anchorX);\n    xStep = 1;\n  }\n\n  // anchorX: left - 0, center - 0.5, right - 1\n  let left = x - anchorX * selfWidth;\n  let right = left + selfWidth;\n  let cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n\n  if (cutoffX > 0) {\n    // Needs horizontal adjustment\n    let bestAnchorX = anchorX;\n    let minCutoff = cutoffX;\n    // Test anchorX at xStep between [0, 1]\n    for (anchorX = 0; anchorX <= 1; anchorX += xStep) {\n      left = x - anchorX * selfWidth;\n      right = left + selfWidth;\n      cutoffX = Math.max(0, padding - left) + Math.max(0, right - width + padding);\n      if (cutoffX < minCutoff) {\n        minCutoff = cutoffX;\n        bestAnchorX = anchorX;\n      }\n    }\n    anchorX = bestAnchorX;\n  }\n\n  // Find the name of the new anchor position\n  return (\n    ANCHOR_TYPES.find(positionType => {\n      const anchorPosition = ANCHOR_POSITION[positionType];\n      return anchorPosition.x === anchorX && anchorPosition.y === anchorY;\n    }) || anchor\n  );\n}\n"],"file":"dynamic-position.js"}