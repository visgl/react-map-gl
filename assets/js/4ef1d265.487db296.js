"use strict";(self.webpackChunkproject_website=self.webpackChunkproject_website||[]).push([[7728],{3555:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>u,contentTitle:()=>c,default:()=>h,frontMatter:()=>l,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"get-started/tips-and-tricks","title":"Tips and Tricks","description":"Securing Mapbox Token","source":"@site/../docs/get-started/tips-and-tricks.md","sourceDirName":"get-started","slug":"/get-started/tips-and-tricks","permalink":"/react-map-gl/docs/get-started/tips-and-tricks","draft":false,"unlisted":false,"editUrl":"https://github.com/visgl/react-map-gl/tree/master/docs/../docs/get-started/tips-and-tricks.md","tags":[],"version":"current","frontMatter":{},"sidebar":"defaultSidebar","previous":{"title":"Adding Custom Data","permalink":"/react-map-gl/docs/get-started/adding-custom-data"},"next":{"title":"default (Map)","permalink":"/react-map-gl/docs/api-reference/mapbox/map"}}');var r=t(4848),s=t(8453),o=t(1470),i=t(9365);const l={},c="Tips and Tricks",u={},d=[{value:"Securing Mapbox Token",id:"securing-mapbox-token",level:2},{value:"Minimize Cost from Frequent Re-mounting",id:"minimize-cost-from-frequent-re-mounting",level:2},{value:"Performance with Many Markers",id:"performance-with-many-markers",level:2},{value:"Finding out if a point is within the current viewport",id:"finding-out-if-a-point-is-within-the-current-viewport",level:2}];function p(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"tips-and-tricks",children:"Tips and Tricks"})}),"\n",(0,r.jsx)(n.h2,{id:"securing-mapbox-token",children:"Securing Mapbox Token"}),"\n",(0,r.jsx)(n.p,{children:"Because Mapbox tokens are required for the client application to make requests to Mapbox servers, you have to distribute it with your app. It is not possible to stop a visitor to your site from scraping the token. The practice outlined below can help you protect your token from being abused."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Never commit your token in clear text into GitHub or other source control."}),"\n",(0,r.jsxs)(n.li,{children:["In your local dev environment, define the token in an environment variable e.g. ",(0,r.jsx)(n.code,{children:"MapboxAccessTokenDev=..."})," in the command line, or use something like ",(0,r.jsx)(n.a,{href:"https://github.com/motdotla/dotenv",children:"dotenv"})," and put ",(0,r.jsx)(n.code,{children:"MapboxAccessTokenDev=..."})," in a ",(0,r.jsx)(n.code,{children:".env"})," file. Add ",(0,r.jsx)(n.code,{children:".env"})," to ",(0,r.jsx)(n.code,{children:".gitignore"})," so it's never tracked. If your app is deployed by a continuous integration pipeline, follow its documentation and set a secret environment variable."]}),"\n",(0,r.jsxs)(n.li,{children:["Create separate tokens for development (often times on ",(0,r.jsx)(n.code,{children:"http://localhost"}),"), public code snippet (Gist, Codepen etc.) and production (deployed to ",(0,r.jsx)(n.code,{children:"https://mycompany.com"}),"). The public token should be rotated regularly. The production token should have strict ",(0,r.jsx)(n.a,{href:"https://docs.mapbox.com/help/troubleshooting/how-to-use-mapbox-securely/#access-tokens",children:"scope and URL restrictions"})," that only allows it to be used on a domain that you own."]}),"\n",(0,r.jsx)(n.li,{children:"Add the following to your bundler config:"}),"\n"]}),"\n","\n",(0,r.jsxs)(o.A,{children:[(0,r.jsx)(i.A,{value:"webpack",label:"Webpack",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/// webpack.config.js\nconst {DefinePlugin} = require('webpack');\n\nmodule.exports = {\n  ...\n  plugins: [\n    new DefinePlugin({\n      'process.env.MapboxAccessToken': JSON.stringify(process.env.NODE_ENV == 'production' ? process.env.MapboxAccessTokenProd : process.env.MapboxAccessTokenDev)\n    })\n  ]\n};\n"})})}),(0,r.jsx)(i.A,{value:"rollup",label:"Rollup",children:(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"/// rollup.config.js\nconst replace = require('@rollup/plugin-replace').default;\n\nmodule.exports = {\n  ...\n  plugins: [\n    replace({ \n      'process.env.MapboxAccessToken': JSON.stringify(process.env.NODE_ENV == 'production' ? process.env.MapboxAccessTokenProd : process.env.MapboxAccessTokenDev)\n    })\n  ]\n};\n"})})})]}),"\n",(0,r.jsxs)(n.p,{children:["react-map-gl automatically picks up ",(0,r.jsx)(n.code,{children:"process.env.MapboxAccessToken"})," or ",(0,r.jsx)(n.code,{children:"process.env.REACT_APP_MAPBOX_ACCESS_TOKEN"})," if they are defined. Alternatively, you can use your own variable name (e.g. ",(0,r.jsx)(n.code,{children:"__SUPER_SECRET_TOKEN__"}),") and pass it in manually with ",(0,r.jsx)(n.code,{children:"mapboxAccessToken={__SUPER_SECRET_TOKEN__}"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"minimize-cost-from-frequent-re-mounting",children:"Minimize Cost from Frequent Re-mounting"}),"\n",(0,r.jsx)(n.p,{children:"In a moderately complex single-page app, as the user navigates through the UI, a map component may unmount and mount again many times during a session. Consider the following layout:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'/// Example using Tabs from Material UI\n<TabContext value={selectedTab}>\n  <TabList onChange={handleTabChange}>\n    <Tab label="Map" value="map" />\n    <Tab label="List" value="table" />\n  </TabList>\n  <TabPanel value="map">\n    <Map mapStyle="mapbox://styles/mapbox/streets-v9" >\n      {items.map(renderMarker)}\n    </Map>\n  </TabPanel>\n  <TabPanel value="table">\n    <Table>\n      {items.map(renderRow)}\n    </Table>\n  </TabPanel>\n</TabContext>\n'})}),"\n",(0,r.jsxs)(n.p,{children:['Every time the user clicks the "table" tab, the map is unmounted. When they click the "map" tab, the map is mounted again. As of v2.0, mapbox-gl generates a ',(0,r.jsx)(n.a,{href:"https://www.mapbox.com/pricing#maploads",children:"billable event"})," every time a Map object is initialized. It is obviously not ideal to get billed for just collapsing and expanding part of the UI."]}),"\n",(0,r.jsxs)(n.p,{children:["In this case, it is recommended that you set the ",(0,r.jsx)(n.a,{href:"/react-map-gl/docs/api-reference/mapbox/map#reuseMaps",children:"reuseMaps"})," prop to ",(0,r.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'  <TabPanel value="map">\n    <Map reuseMaps mapStyle="mapbox://styles/mapbox/streets-v9" >\n      {items.map(renderMarker)}\n    </Map>\n  </TabPanel>\n'})}),"\n",(0,r.jsx)(n.p,{children:"This bypasses the initialization when a map is removed then added back."}),"\n",(0,r.jsx)(n.h2,{id:"performance-with-many-markers",children:"Performance with Many Markers"}),"\n",(0,r.jsx)(n.p,{children:"If your application uses externally managed camera state, like with Redux, the number of React rerenders may be very high when the user is interacting with the map. Consider the following setup:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"import {useSelector, useDispatch} from 'react-redux';\nimport Map, {Marker} from 'react-map-gl/maplibre';\n\nfunction MapView() {\n  const viewState = useSelector((s: RootState) => s.viewState);\n  const vehicles = useSelector((s: RootState) => s.vehicles);\n  const dispatch = useDispatch();\n\n  const onMove = useCallback(evt => {\n    dispatch({type: 'setViewState', payload: evt.viewState});\n  }, []);\n\n  return (\n    <Map\n      {...viewState}\n      onMove={onMove}\n      mapStyle=\"mapbox://styles/mapbox/streets-v9\" >\n    >\n      {vehicles.map(vehicle => (\n        <Marker key={vehicle.id}\n          longitude={vehicle.coordinates[0]}\n          latitude={vehicle.coordinates[1]}>\n          <svg>\n            // vehicle icon\n          </svg>\n        </Marker>)\n      )}\n    </Map>\n  );\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"This component is rerendered on every animation frame when the user is dragging the map. If it's trying to render hundreds of markers, the performance lag will become quite visible."}),"\n",(0,r.jsxs)(n.p,{children:["One way to improve the performance is ",(0,r.jsx)(n.code,{children:"useMemo"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'  const markers = useMemo(() => vehicles.map(vehicle => (\n    <Marker key={vehicle.id}\n      longitude={vehicle.coordinates[0]}\n      latitude={vehicle.coordinates[1]}>\n      <svg>\n        // vehicle icon\n      </svg>\n    </Marker>)\n  ), [vehicles]);\n\n  return (\n    <Map\n      {...viewState}\n      onMove={onMove}\n      mapStyle="mapbox://styles/mapbox/streets-v9" >\n    >\n      {markers}\n    </Map>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"This prevents React from rerendering the markers unless they have changed."}),"\n",(0,r.jsxs)(n.p,{children:["If your application can do without complicated DOM objects and CSS styling, consider switching to a ",(0,r.jsx)(n.a,{href:"https://docs.mapbox.com/mapbox-gl-js/style-spec/layers/#symbol",children:"symbol layer"}),". Layers are rendered in WebGL and are much more performant than markers:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"  const vehiclesGeoJSON = useMemo(() => {\n    return {\n      type: 'FeatureCollection',\n      features: vehicles.map(vehicle => turf.point(vehicle.coordinates, vehicle))\n    };\n  }, [vehicles]);\n\n  return (\n    <Map\n      {...viewState}\n      onMove={onMove}\n      mapStyle=\"mapbox://styles/mapbox/streets-v9\" >\n    >\n      <Source id=\"vehicles\" type=\"geojson\" data={vehiclesGeoJSON}>\n        <Layer type=\"symbol\"\n          layout={{\n            'icon-image': 'vehicle-icon',\n            'icon-size': 1,\n            'text-field': ['get', 'id']\n          }}\n        />\n      </Source>\n    </Map>\n  );\n"})}),"\n",(0,r.jsx)(n.h2,{id:"finding-out-if-a-point-is-within-the-current-viewport",children:"Finding out if a point is within the current viewport"}),"\n",(0,r.jsxs)(n.p,{children:["There are some situations where you want to know if a point is currently visible on the map.",(0,r.jsx)(n.br,{}),"\n","Checking this is simple and can be done like so:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const mapRef = useRef<MapRef>();\n\nconst checkIfPositionInViewport = (lat, lng) => {\n    const bounds = mapRef.current.getBounds();\n    return bounds.contains([lng, lat]);\n}\n\nreturn <Map ref={mapRef} ... />\n"})})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},9365:(e,n,t)=>{t.d(n,{A:()=>o});t(6540);var a=t(4164);const r={tabItem:"tabItem_Ymn6"};var s=t(4848);function o(e){let{children:n,hidden:t,className:o}=e;return(0,s.jsx)("div",{role:"tabpanel",className:(0,a.A)(r.tabItem,o),hidden:t,children:n})}},1470:(e,n,t)=>{t.d(n,{A:()=>k});var a=t(6540),r=t(4164),s=t(3104),o=t(6347),i=t(205),l=t(7485),c=t(1682),u=t(679);function d(e){var n,t;return null!=(n=null==(t=a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})))?void 0:t.filter(Boolean))?n:[]}function p(e){const{values:n,children:t}=e;return(0,a.useMemo)((()=>{const e=null!=n?n:function(e){return d(e).map((e=>{let{props:{value:n,label:t,attributes:a,default:r}}=e;return{value:n,label:t,attributes:a,default:r}}))}(t);return function(e){const n=(0,c.XI)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error('Docusaurus error: Duplicate values "'+n.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.')}(e),e}),[n,t])}function h(e){let{value:n,tabValues:t}=e;return t.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:t}=e;const r=(0,o.W6)(),s=function(e){let{queryString:n=!1,groupId:t}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!t)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return null!=t?t:null}({queryString:n,groupId:t});return[(0,l.aZ)(s),(0,a.useCallback)((e=>{if(!s)return;const n=new URLSearchParams(r.location.search);n.set(s,e),r.replace(Object.assign({},r.location,{search:n.toString()}))}),[s,r])]}function b(e){const{defaultValue:n,queryString:t=!1,groupId:r}=e,s=p(e),[o,l]=(0,a.useState)((()=>function(e){var n;let{defaultValue:t,tabValues:a}=e;if(0===a.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!h({value:t,tabValues:a}))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+t+'" but none of its children has the corresponding value. Available values are: '+a.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");return t}const r=null!=(n=a.find((e=>e.default)))?n:a[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:n,tabValues:s}))),[c,d]=m({queryString:t,groupId:r}),[b,v]=function(e){let{groupId:n}=e;const t=function(e){return e?"docusaurus.tab."+e:null}(n),[r,s]=(0,u.Dv)(t);return[r,(0,a.useCallback)((e=>{t&&s.set(e)}),[t,s])]}({groupId:r}),g=(()=>{const e=null!=c?c:b;return h({value:e,tabValues:s})?e:null})();(0,i.A)((()=>{g&&l(g)}),[g]);return{selectedValue:o,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:s}))throw new Error("Can't select invalid tab value="+e);l(e),d(e),v(e)}),[d,v,s]),tabValues:s}}var v=t(2303);const g={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var f=t(4848);function x(e){let{className:n,block:t,selectedValue:a,selectValue:o,tabValues:i}=e;const l=[],{blockElementScrollPositionUntilNextRender:c}=(0,s.a_)(),u=e=>{const n=e.currentTarget,t=l.indexOf(n),r=i[t].value;r!==a&&(c(n),o(r))},d=e=>{var n;let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{var a;const n=l.indexOf(e.currentTarget)+1;t=null!=(a=l[n])?a:l[0];break}case"ArrowLeft":{var r;const n=l.indexOf(e.currentTarget)-1;t=null!=(r=l[n])?r:l[l.length-1];break}}null==(n=t)||n.focus()};return(0,f.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.A)("tabs",{"tabs--block":t},n),children:i.map((e=>{let{value:n,label:t,attributes:s}=e;return(0,f.jsx)("li",Object.assign({role:"tab",tabIndex:a===n?0:-1,"aria-selected":a===n,ref:e=>{l.push(e)},onKeyDown:d,onClick:u},s,{className:(0,r.A)("tabs__item",g.tabItem,null==s?void 0:s.className,{"tabs__item--active":a===n}),children:null!=t?t:n}),n)}))})}function y(e){let{lazy:n,children:t,selectedValue:s}=e;const o=(Array.isArray(t)?t:[t]).filter(Boolean);if(n){const e=o.find((e=>e.props.value===s));return e?(0,a.cloneElement)(e,{className:(0,r.A)("margin-top--md",e.props.className)}):null}return(0,f.jsx)("div",{className:"margin-top--md",children:o.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==s})))})}function j(e){const n=b(e);return(0,f.jsxs)("div",{className:(0,r.A)("tabs-container",g.tabList),children:[(0,f.jsx)(x,Object.assign({},n,e)),(0,f.jsx)(y,Object.assign({},n,e))]})}function k(e){const n=(0,v.A)();return(0,f.jsx)(j,Object.assign({},e,{children:d(e.children)}),String(n))}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var a=t(6540);const r={},s=a.createContext(r);function o(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);